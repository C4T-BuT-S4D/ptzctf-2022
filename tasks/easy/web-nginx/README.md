# easy | web | nginx

## Описание
Все мы любим nginx...
[http://{IP}:8384](http://{IP}:8384)

## Информация
По конфигу nginx'а необходимо составить правильный запрос.

## Решение
Видно, что в конфиге задано 2 сайта - на одном отдаётся статический html, а другой выглядит более интересно. Начнём проходить поэтапно.

1. `server_name ""` будет отдавать отвечать только на те запросы, у которых заголовок `Host` не выставлен. Т.к. это недопустимо в протоколе версии `HTTP/1.1`, придётся использовать `HTTP/1.0`.
2. `valid_referers` проверяет, что у пользователя выставлен конкретный заголовок `Referer`, в данном случае `Referer` должен содержать сайт со строкой `omegalulz`. Подойдет `Referer: http://omegalulz`.
3. `ancient_browser` и `modern_browser` выставляют переменные `ancient_browser` и `modern_browser` в зависимости от значения заголовка `User-Agent`. `modern_browser unlisted`, как в нашем случае, обозначает, что `ancient_browser = 0` тогда, когда `User-Agent` не входит в список, перечисленный в директиве `ancient_browser`. Можно, например, просто убрать значение заголовка `User-Agent`.
4. `auth_request /auth` заставит пользователя авторизовываться в каждом запросе. В конфиге авторизация задана как проксирование запроса на `https://httpbin.org/bearer`, если погуглить и поковыряться в его исходниках, станет понятно, что необходимо просто добавить заголовок `Authorization: Bearer что-то`. (https://github.com/postmanlabs/httpbin/blob/f8ec666b4d1b654e4ff6aedd356f510dcac09f83/httpbin/core.py#L1000).
5. На данном этапе мы уже можем сделать нормальный запрос:
   ```bash
   curl http://localhost:8384/ -i -H "Host:" --http1.0 -H "Referer: http://omegalulz" -H "User-Agent:" -H "Authorization: Bearer 1"
   ```
   Но, к сожалению, в ответ мы получим нечто непонятное:
   ```
   <8aTO>
   <87eq><asaO7>9Hq7F YV /</asaO7></87eq>
   <MYq}>
   <8B>9Hq7F YV /</8B><8D><WD7><e 8D7V="../">../</e>
   <e 8D7V="ZjqBV7Zo7hhorhuk6V6{.aFa">ZjqBV7Zo7hhorhuk6V6{.aFa</e>                           uZ-XYy-jujj jB:h{                  oj
   </WD7><8D></MYq}>
   </8aTO>
   ```
   Объясняется это директивами `charset_map`, `source_charset` и `charset`, которые изменяют кодировку ответа, следуя заданной таблице перевода. По этой таблице мы можем перевести в изначальную кодировку:
   ```
   ...
   <a href="62d1fe64e55435079f98.txt">62d1fe64e55435079f98.txt</a>
   ...
   ```
6. Запросив найденный файл аналогичным образом, и переведя ответ, получим флаг.

[Эксплоит](solve/solve.py)

## Флаг
`ptzctf{nginxisfunlol_6e0fbd98503acbdcedd4}`
